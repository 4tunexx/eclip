# Cosmetics — Avatar Frames & Profile Banners

This document explains how cosmetics are implemented in EquipGG (avatar frames and profile banners), where the code lives, how the backend & front-end interact, and how an admin can manage/add new cosmetics. It includes concrete code snippets, API references, database considerations, and tips for testing.

---

## Overview

Cosmetics in EquipGG provide profile personalization for users. Two classes are implemented today:

- Avatar Frames (Decorative circular borders around avatars) — implemented in `src/lib/avatar-frames.ts`
- Profile Banners (Header / background used on user profiles) — implemented in `src/lib/profile-banners.ts`

Both systems support:
- A small, built-in collection of hard-coded cosmetics (files above) for instant availability.
- Admin CRUD endpoints to add or change cosmetics in the database under a `cosmetics` table.
- Client APIs for users to purchase, equip, and view owned cosmetics.

Cosmetics are intentionally implemented to work in environments where DB tables may not exist (development flexibility). The admin APIs try to be robust and return usable built-in fallback data when the DB is not present.

---

## Where the code lives

- lib / baked-in data (defaults)
  - `src/lib/avatar-frames.ts` — avatar frame definitions and helpers (styles, animation helpers)
  - `src/lib/profile-banners.ts` — banner definitions and helpers (gradient strings, image urls)

- Public-facing shop & profile features
  - `src/app/dashboard/shop/page.tsx` — UI for users to view and buy cosmetics
  - `src/app/api/cosmetics/purchase/route.ts` — POST to buy a cosmetic (handles VIP & verification checks)
  - `src/app/api/cosmetics/equip/route.ts` — POST to equip a cosmetic
  - `src/app/api/cosmetics/owned/route.ts` — GET to list the user's owned & equipped cosmetics

- Admin APIs (CRUD)
  - `src/app/api/admin/cosmetics/frames/route.ts` — GET/POST avatar frames
  - `src/app/api/admin/cosmetics/frames/[id]/route.ts` — PUT/DELETE a specific frame
  - `src/app/api/admin/cosmetics/banners/route.ts` — GET/POST banners
  - `src/app/api/admin/cosmetics/banners/[id]/route.ts` — PUT/DELETE a specific banner

---

## Data model (DB tables)

Recommended and existing tables used by the API routes:

1) `cosmetics` — master table for custom cosmetics stored in DB
   - id (string, PK)
   - name (string)
   - description (text)
   - cosmetic_type (string) — e.g., `avatar_frame` or `banner`
   - image_url (string) — preview image path for the shop
   - price (number) — coin price
   - rarity (string) — common/uncommon/rare/epic/legendary
   - is_vip (boolean), vip_tier_required (string) — optional VIP constraints
   - additional fields depending on type:
     - avatar_frame: border_color, border_width, border_style, shadow_color, animation_type, animation_speed
     - banner: gradient (string CSS gradient)
   - is_active, created_at, updated_at

2) `user_cosmetics` — records what a user owns
   - id, user_id, cosmetic_id, cosmetic_type, purchased_at, equipped (boolean)

3) `users` — columns used for cosmetics
   - equipped_avatar_frame (string) — cosmetic id
   - equipped_banner (string) — cosmetic id

Note: Admin routes perform graceful fallbacks for missing tables (to allow development without a full migration), but in production you should create the `cosmetics` and `user_cosmetics` tables via a migration.

---

## How the system works (flow)

1. The code bundles a baseline set of cosmetics in `src/lib/avatar-frames.ts` and `src/lib/profile-banners.ts` so the site always has defaults.
2. Admin can add/edit/delete additional cosmetics using the admin endpoints under `/api/admin/cosmetics/*` — these insert rows into `cosmetics` (type column identifies frame vs banner).
3. Users buy cosmetics using `/api/cosmetics/purchase` (which deducts coins and adds a `user_cosmetics` row). The front-end `Shop` page calls this endpoint.
4. Users equip purchased cosmetics using `/api/cosmetics/equip` — that updates `users.equipped_banner` and/or `users.equipped_avatar_frame` and marks `user_cosmetics.equipped`.
5. User UI (profile and chat) reads `/api/cosmetics/owned` to show owned cosmetics and detect equipped items.

---

## Admin: How to add/update Avatar Frames (API & snippet)

Admin-only endpoints allow created/changes. Below are examples and the minimal shape required to create or update.

1) Create (POST /api/admin/cosmetics/frames)

Request JSON (required fields highlighted):

```json
{
  "id": "frame_glow_blue_v2",
  "name": "Electric Blue Glow v2",
  "description": "Upgraded glowing frame",
  "border_color": "#3b82f6",
  "border_width": 5,
  "border_style": "solid",
  "shadow_color": "rgba(59,130,246,0.8)",
  "animation_type": "glow",
  "animation_speed": 4,
  "price": 250,
  "rarity": "uncommon",
  "image_url": "/images/frames/glow-blue-v2.png",
  "is_vip": false,
  "vip_tier_required": "none",
  "is_active": true
}
```

2) Update (PUT /api/admin/cosmetics/frames/[id])

Request JSON: any partial of the create shape — server merges updates.

3) Delete (DELETE /api/admin/cosmetics/frames/[id])

Notes:
- The admin endpoints expect an admin session (cookie-based auth). The routes call `getAuthSession()` and check `session.role === 'admin'`.

---

## Admin: How to add/update Profile Banners (API & snippet)

1) Create (POST /api/admin/cosmetics/banners)

Request JSON (required `id`, `name`, `gradient`):

```json
{
  "id": "banner_new_dusk",
  "name": "Dusk Horizon",
  "description": "Warm dusk tones",
  "gradient": "linear-gradient(135deg, rgb(250 204 21 / 0.4), rgb(236 72 153 / 0.4))",
  "price": 350,
  "rarity": "rare",
  "image_url": "/images/banners/dusk.png",
  "is_vip": false,
  "vip_tier_required": "none",
  "is_active": true
}
```

2) Update (PUT /api/admin/cosmetics/banners/[id]) — same shape allowed for partial updates.

3) Delete (DELETE /api/admin/cosmetics/banners/[id])

---

## Client usage / rendering snippets

1) Rendering avatar frames around a user avatar (React)

Files to import from repo:
- `src/lib/avatar-frames.ts` — helpers: `getFrameStyle(frame)` and `getFrameAnimationClass(frame)`.

Snippet:

```tsx
import { getFrameById, getFrameStyle, getFrameAnimationClass, getDefaultFrame } from '@/lib/avatar-frames';

function ProfileAvatar({ user }) {
  const frameId = user?.equipped_avatar_frame || 'frame_default';
  const frame = getFrameById(frameId) || getDefaultFrame();

  return (
    <div style={{ width: 96, height: 96, ...getFrameStyle(frame) }} className={getFrameAnimationClass(frame)}>
      <img src={user.avatar || '/assets/placeholder-avatar.svg'} alt="Avatar" style={{ width: '100%', height: '100%', borderRadius: '50%' }} />
    </div>
  );
}
```

Notes:
- `getFrameStyle` returns the core CSS to apply to a circular container (border, shadow). Be sure to keep the image inside with `border-radius: 50%`.
- `getFrameAnimationClass` returns a Tailwind animation class. Make sure to include the animations in `tailwind.config.ts` (the repo already defines `animate-glow-*`, etc.).

2) Rendering a profile banner (React)

Use gradient or image depending on cosmetic metadata; banners in `PROFILE_BANNERS` provide image_url and gradient.

```tsx
import { getBannerById, getDefaultBanner } from '@/lib/profile-banners';

function ProfileBanner({ user }) {
  const bannerId = user?.equipped_banner || 'banner_default';
  const banner = getBannerById(bannerId) || getDefaultBanner();

  return (
    <div style={{ height: 140, background: banner.gradient }} className="w-full rounded-xl overflow-hidden">
      {banner.image_url && (
        <img src={banner.image_url} alt={banner.name} className="w-full h-full object-cover opacity-80" />
      )}
    </div>
  );
}
```

3) Buying and equipping a cosmetic (client actions)

Purchase example (Shop page):

```ts
await fetch('/api/cosmetics/purchase', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ cosmeticId: 'frame_glow_blue' }),
  credentials: 'include'
});
```

Equip example: (when clicking equip in profile settings)

```ts
await fetch('/api/cosmetics/equip', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ cosmeticId: 'frame_glow_blue' }),
  credentials: 'include'
});
```

4) Fetching owned cosmetics

```ts
const res = await fetch('/api/cosmetics/owned', { credentials: 'include' });
const json = await res.json();
// json.cosmetics is an array of enriched cosmetics (includes default baked-in items)
```

---

## Admin UI notes & snippets

Where admin routes are used in the repository:
- `src/app/api/admin/cosmetics/frames/route.ts` and `.../banners/route.ts` — these are the REST endpoints the admin UI should call.
- The `src/app/dashboard/shop/page.tsx` demonstrates client usage to buy/equip cosmetics — admin dashboard pages (if created) can use the admin endpoints for management.

Important snippets to add to an admin UI (example code):

1) Fetch all frames for admin management (GET)

```ts
const res = await fetch('/api/admin/cosmetics/frames', { credentials: 'include' });
const { frames } = await res.json();
// Render and allow edit/delete for each item
```

2) Create new frame (POST)

See earlier POST shape. Use `fetch('/api/admin/cosmetics/frames', { method: 'POST', body: JSON.stringify(payload), credentials: 'include' })`.

3) Update a frame (PUT)

```ts
await fetch(`/api/admin/cosmetics/frames/${frameId}`, { method: 'PUT', credentials: 'include', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(updates) });
```

4) Delete (DELETE)

```ts
await fetch(`/api/admin/cosmetics/frames/${frameId}`, { method: 'DELETE', credentials: 'include' });
```

---

## Security & validation notes

- Admin endpoints require a session and `session.role === 'admin'`. They rely on the `getAuthSession` helper.
- `purchase` endpoint checks verification status (see `checkBalanceAccess`) and VIP requirements before deducting coins.
- `equip` endpoint verifies ownership in `user_cosmetics` but contains graceful fallbacks when the table does not exist (so tests / dev don't break).

Important validation rules you should keep or add:
- Validate incoming CSS gradient strings or sanitize them if you allow custom CSS on DB-driven banners.
- Limit sizes for uploaded preview images and validate that `image_url` points to images.
- Use a service role or server-side upload helper for storing actual files (e.g., Supabase storage) and never accept raw base64 in public admin endpoints without server-side processing.

---

## Migrations & DB setup (recommended)

Add a `cosmetics` table with appropriate columns and a `user_cosmetics` table to track ownership/equipped state. Example simplified SQL (adapt to your migration style):

```sql
CREATE TABLE cosmetics (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  cosmetic_type TEXT NOT NULL,
  image_url TEXT,
  price INTEGER DEFAULT 0,
  rarity TEXT DEFAULT 'common',
  is_vip BOOLEAN DEFAULT false,
  vip_tier_required TEXT DEFAULT 'none',
  gradient TEXT, -- banners only
  border_color TEXT, -- frames only
  border_width INTEGER,
  border_style TEXT,
  shadow_color TEXT,
  animation_type TEXT,
  animation_speed INTEGER,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE user_cosmetics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  cosmetic_id TEXT NOT NULL,
  cosmetic_type TEXT NOT NULL,
  purchased_at TIMESTAMP DEFAULT NOW(),
  equipped BOOLEAN DEFAULT FALSE
);

ALTER TABLE users ADD COLUMN IF NOT EXISTS equipped_avatar_frame TEXT;
ALTER TABLE users ADD COLUMN IF NOT EXISTS equipped_banner TEXT;
```

---

## Useful tips & debugging

- To test the shop quickly use the baked-in lists in `src/lib/profile-banners.ts` and `src/lib/avatar-frames.ts` — they always exist and don't require DB.
- Admins should prefer creating cosmetics via admin API or migrations so they persist across deployments.
- If something doesn't show up: check `user_cosmetics` and `users.equipped_*` columns and ensure front-end reads `/api/cosmetics/owned` and updates UI accordingly.

---

## Final checklist for adding new cosmetic assets

1. Add preview graphics under `public/images/frames/` or `public/images/banners/`.
2. Create a small record in `src/lib/avatar-frames.ts` or `src/lib/profile-banners.ts` for development preview (optional if you prefer DB-only).
3. Add a DB row via the admin API (`POST /api/admin/cosmetics/*`) or via a migration.
4. Make sure `user_cosmetics` linking and purchase endpoints work; create test user flow in Shop UI.
5. Add tests for purchase flow, equip flow, and call the `owned` endpoint to confirm visibility.

---

If you'd like, I can now create the admin UI screens and/or a DB migration — which would you prefer next?
